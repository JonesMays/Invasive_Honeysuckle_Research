# -*- coding: utf-8 -*-
"""CNN (No traits shown)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x4i68UW8vG6a3-ViynzbCpKf8ReYMEJp

Source that helped me
//APA style//

freeCodeCamp.org. “Keras with TensorFlow Course - Python Deep Learning and Neural Networks for Beginners Tutorial.” Www.youtube.com, 18 June 2020, www.youtube.com/watch?v=qFJeN9V1ZsI.
Scikit-learn: Machine Learning in Python, Pedregosa et al., JMLR 12, pp. 2825-2830, 2011.
Verma, Mayank. “Binary Classification Using Convolution Neural Network (CNN) Model.” Medium, 13 Nov. 2020, medium.com/@mayankverma05032001/binary-classification-using-convolution-neural-network-cnn-model-2635ddcdc510. Accessed 1 May 2022.
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing all of the necessary files #

import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Activation, Dense, Flatten, BatchNormalization, Conv2D, MaxPool2D, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import CategoricalCrossentropy
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import confusion_matrix
import itertools
from keras.models import *
import os
from google.colab.patches import cv2_imshow
import shutil
import random
import glob
import matplotlib.pyplot as plt
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
# %matplotlib

# Creating the folders in the Google drive #
# Please a note that the imagedata file may be in a diffrent location for your device #

os.chdir('/content/drive/MyDrive/Colab Notebooks/Imagedata')
if os.path.isdir('train/Honeysuckle') is False:
  os.makedirs('train/Honeysuckle')
  os.makedirs('train/NotHoneysuckle')
  os.makedirs('valid/Honeysuckle')
  os.makedirs('valid/NotHoneysuckle')
  os.makedirs('test/Honeysuckle')
  os.makedirs('test/NotHoneysuckle')

"""Preparing data and puting them into floders"""

#This puts the images into the folders#
#Should only be run once #

os.chdir('/content/drive/MyDrive/Colab Notebooks/Imagedata')
if os.path.isdir('valid/Honeysuckle') is True:

  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata/train/Plants*'), 300):
    shutil.move(c, 'train/Honeysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata/train/Background*'), 300):
    shutil.move(c, 'train/NotHoneysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata/train/Plants*'), 100):
    shutil.move(c, 'valid/Honeysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata/train/Background*'), 100):
    shutil.move(c, 'valid/NotHoneysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata/train/Plants*'), 100):
    shutil.move(c, 'test/Honeysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata/train/Background*'), 100):
    shutil.move(c, 'test/NotHoneysuckle' )

#Pathway varables

train_path = '/content/drive/MyDrive/Colab Notebooks/Imagedata/train'
valid_path = '/content/drive/MyDrive/Colab Notebooks/Imagedata/valid'
test_path = '/content/drive/MyDrive/Colab Notebooks/Imagedata/test'

# Reformats the images #
# Changes the colors to 0 to 1 float #
# Should be 600,200,200 images returned #

train_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
  .flow_from_directory(directory = train_path, target_size = (244,244), classes = ['Honeysuckle', 'NotHoneysuckle'], class_mode = 'binary', batch_size=25)
valid_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
  .flow_from_directory(directory = valid_path, target_size = (244,244), classes = ['Honeysuckle', 'NotHoneysuckle'], class_mode = 'binary', batch_size=25)
test_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
  .flow_from_directory(directory = test_path, target_size = (244,244), classes = ['Honeysuckle', 'NotHoneysuckle'], class_mode = 'binary', batch_size=25, shuffle = False)

#This makes sure that the images are in the correct location and that there it the correct amount of them #

assert train_batches.n == 600
assert valid_batches.n == 200
assert test_batches.n == 200
assert train_batches.num_classes == valid_batches.num_classes == test_batches.num_classes == 2

#Informs you of what sets are named and their correct value #

test_batches.class_indices

#plot images
imgs, labels = next(train_batches)

def plotImages(images_arr):
  fig, axes = plt.subplots(1, 10, figsize = (20, 20))
  axes = axes.flatten()
  for img, ax in zip(images_arr, axes):
    ax.imshow(img)
    ax.axis('off')
  plt.tight_layout()
  plt.show()

# Commented out IPython magic to ensure Python compatibility.
# Plotting images #
# The colors will be changed since the range was changed to a float #

import matplotlib.image as mpimg
from matplotlib.pyplot import imshow
# %matplotlib inline

plotImages(imgs)
print(labels)

# Sequential model that is supposed to detect the high level features of the plant #

model = Sequential([
    Conv2D(filters=16, kernel_size=(3,3), activation = 'relu', padding = 'same', input_shape=(244, 244, 3)),
    MaxPool2D(pool_size=(2,2), strides = 2), (Dropout(.5)),

    Conv2D(filters=32, kernel_size=(3,3), activation = 'relu', padding = 'same'),
    MaxPool2D(pool_size=(2,2), strides = 2), (Dropout(.5)),

    Conv2D(filters=64, kernel_size=(3,3), activation = 'relu', padding = 'same'),
    MaxPool2D(pool_size=(2,2), strides = 2), (Dropout(.5)),

    Flatten(),
    Dense(units=1, activation='sigmoid'),
])

model.summary()

model.compile(optimizer=Adam(learning_rate=.0001), loss='binary_crossentropy', metrics =['accuracy'])

model.fit(x=train_batches, validation_data=valid_batches, epochs=25, verbose=1)

test_imgs, test_labels = next(test_batches)
plotImages(test_imgs)
print(test_labels)

test_batches.classes

predictions = model.predict(x=test_batches, verbose=0)

np.round(predictions)

cm = confusion_matrix(y_true=test_batches.classes, y_pred=np.round(predictions))

import matplotlib.pyplot as plt
def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap= plt.cm.Blues):

  plt.imshow(cm, interpolation='nearest', cmap=cmap)
  plt.title(title)
  plt.colorbar()
  tick_marks = np.arange(len(classes))
  plt.xticks(tick_marks, classes, rotation=45)
  plt.yticks(tick_marks, classes)

  if normalize:
    cm = cm.astype('float')/ cm.sum(axis=1)[:, np.newaxis]
    print("Normalized confusion matric")
  else:
    print('Confusion matrix, without normalization')

  print(cm)

  thresh = cm.max()/2
  for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
    plt.text(j, i, cm[i, j],
            horizontalalignment= "center",
            color="white" if cm[i,j] > thresh else "black")

  plt.tight_layout()
  plt.ylabel('True label')
  plt.xlabel('Predicted label')

cm_plot_labels = ['Honeysuckle', 'NotHoneysuckle']
plot_confusion_matrix(cm=cm, classes=cm_plot_labels, title= 'confusion Matrix')

from sklearn import svm
from sklearn.metrics import roc_curve, auc
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import label_binarize
from sklearn.multiclass import OneVsRestClassifier
from scipy import interp
from sklearn.metrics import roc_auc_score

fpr, tpr, _ = roc_curve(test_batches.classes, predictions)
roc_auc = auc(fpr, tpr)
plt.figure()
lw = 2
plt.plot(fpr, tpr, color='darkorange',
lw=lw, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic example')
plt.legend(loc="lower right")
plt.show()