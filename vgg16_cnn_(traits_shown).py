# -*- coding: utf-8 -*-
"""VGG16 CNN (traits shown)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p1TDPmsG2Q_U7ZvftEe9Ov4xDOcYIOPt

Source that helped me
//APA style//

freeCodeCamp.org. “Keras with TensorFlow Course - Python Deep Learning and Neural Networks for Beginners Tutorial.” Www.youtube.com, 18 June 2020, www.youtube.com/watch?v=qFJeN9V1ZsI.
Scikit-learn: Machine Learning in Python, Pedregosa et al., JMLR 12, pp. 2825-2830, 2011.
Verma, Mayank. “Binary Classification Using Convolution Neural Network (CNN) Model.” Medium, 13 Nov. 2020, medium.com/@mayankverma05032001/binary-classification-using-convolution-neural-network-cnn-model-2635ddcdc510. Accessed 1 May 2022.
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Activation, Dense, Flatten, BatchNormalization, Conv2D, MaxPool2D, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import CategoricalCrossentropy
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import confusion_matrix
import itertools
import os
from google.colab.patches import cv2_imshow
import shutil
import random
import glob
import matplotlib.pyplot as plt
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
# %matplotlib

# You have to connect the file with your google drive#
# Creating the folders in the Google drive #
# Please note that the imagedata file may be in a diffrent location #

os.chdir('/content/drive/MyDrive/Colab Notebooks/Imagedata2')
if os.path.isdir('train/Honeysuckle') is False:
  os.makedirs('train/Honeysuckle')
  os.makedirs('train/NotHoneysuckle')
  os.makedirs('valid/Honeysuckle')
  os.makedirs('valid/NotHoneysuckle')
  os.makedirs('test/Honeysuckle')
  os.makedirs('test/NotHoneysuckle')

from typing_extensions import TypeVarTuple
# This puts the images into the folders#
#Please only run once #

os.chdir('/content/drive/MyDrive/Colab Notebooks/Imagedata2')
if os.path.isdir('train/Honeysuckle') is True:

  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata2/train/Flowers*'), 300):
    shutil.move(c, 'train/Honeysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata2/train/Background*'), 300):
    shutil.move(c, 'train/NotHoneysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata2/train/Flowers*'), 100):
    shutil.move(c, 'valid/Honeysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata2/train/Background*'), 100):
    shutil.move(c, 'valid/NotHoneysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata2/train/Flowers*'), 100):
    shutil.move(c, 'test/Honeysuckle' )
  for c in random.sample(glob.glob('/content/drive/MyDrive/Colab Notebooks/Imagedata2/train/Background*'), 100):
    shutil.move(c, 'test/NotHoneysuckle' )

#Pathway varables

train_path = '/content/drive/MyDrive/Colab Notebooks/Imagedata2/train'
valid_path = '/content/drive/MyDrive/Colab Notebooks/Imagedata2/valid'
test_path = '/content/drive/MyDrive/Colab Notebooks/Imagedata2/test'

# Reformats the images

train_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
  .flow_from_directory(directory = train_path, target_size = (244,244), classes = ['Honeysuckle', 'NotHoneysuckle'], class_mode = 'binary', batch_size=32)
valid_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
  .flow_from_directory(directory = valid_path, target_size = (244,244), classes = ['Honeysuckle', 'NotHoneysuckle'], class_mode = 'binary', batch_size=32)
test_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
  .flow_from_directory(directory = test_path, target_size = (244,244), classes = ['Honeysuckle', 'NotHoneysuckle'], class_mode = 'binary', batch_size=32, shuffle = False)

#This makes sure that the images are in the correct location and that there it the correct amount of them

assert train_batches.n == 600
assert valid_batches.n == 200
assert test_batches.n == 200
assert train_batches.num_classes == valid_batches.num_classes == test_batches.num_classes == 2

imgs, labels = next(train_batches)

#plot images
def plotImages(images_arr):
  fig, axes = plt.subplots(1, 10, figsize = (20, 20))
  axes = axes.flatten()
  for img, ax in zip(images_arr, axes):
    ax.imshow(img)
    ax.axis('off')
  plt.tight_layout()
  plt.show()

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.image as mpimg
from matplotlib.pyplot import imshow
# %matplotlib inline

plotImages(imgs)
print(labels)

vgg16_model = tf.keras.applications.vgg16.VGG16()

vgg16_model.summary()

model = Sequential()
for layer in vgg16_model.layers[:-1]:
  model.add(layer)

model.summary()

for layer in model.layers:
  layer.trainable = False

model.add(Dense(units=1, activation='sigmoid'))

model.summary()

model.compile(optimizer=Adam(learning_rate=.0001), loss='binary_crossentropy', metrics =['accuracy'])

model.fit(x=train_batches, validation_data=valid_batches, epochs=5, verbose=1)

test_imgs, test_labels = next(test_batches)
plotImages(test_imgs)
print(test_labels)

test_batches.classes

predictions = model.predict(x=test_batches, verbose=1)

np.round(predictions)

cm = confusion_matrix(y_true=test_batches.classes, y_pred=np.round(predictions))

test_batches.class_indices

import matplotlib.pyplot as plt
def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap= plt.cm.Blues):

  plt.imshow(cm, interpolation='nearest', cmap=cmap)
  plt.title(title)
  plt.colorbar()
  tick_marks = np.arange(len(classes))
  plt.xticks(tick_marks, classes, rotation=45)
  plt.yticks(tick_marks, classes)

  if normalize:
    cm = cm.astype('float')/ cm.sum(axis=1)[:, np.newaxis]
    print("Normalized confusion matric")
  else:
    print('Confusion matrix, without normalization')

  print(cm)

  thresh = cm.max()/2
  for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
    plt.text(j, i, cm[i, j],
            horizontalalignment= "center",
            color="white" if cm[i,j] > thresh else "black")

  plt.tight_layout()
  plt.ylabel('True label')
  plt.xlabel('Predicted label')

cm_plot_labels = ['Honeysuckle', 'NotHoneysuckle']
plot_confusion_matrix(cm=cm, classes=cm_plot_labels, title= 'confusion Matrix')

from sklearn import svm
from sklearn.metrics import roc_curve, auc
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import label_binarize
from sklearn.multiclass import OneVsRestClassifier
from scipy import interp
from sklearn.metrics import roc_auc_score

fpr, tpr, _ = roc_curve(test_batches.classes, predictions)
roc_auc = auc(fpr, tpr)
plt.figure()
lw = 2
plt.plot(fpr, tpr, color='darkorange',
lw=lw, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic example')
plt.legend(loc="lower right")
plt.show()